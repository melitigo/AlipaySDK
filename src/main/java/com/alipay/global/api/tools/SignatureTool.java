package com.alipay.global.api.tools;


/**
 * Alipay.com Inc. Copyright (c) 2004-2019 All Rights Reserved.
 */

import com.alipay.global.api.base64.Base64Encryptor;
import com.alipay.global.api.base64.DefaultBase64Encryptor;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

public class SignatureTool {

    private static final String RSA = "RSA";
    private static final String SHA256WITHRSA = "SHA256withRSA";
    private static final String SHA1WITHRSA = "SHA1withRSA";

    private static Base64Encryptor base64Encryptor = new DefaultBase64Encryptor();

    /**
     * Sign the contents of the merchant request
     *
     * @param reqContent         = httpMethod + " " + uriWithQueryString + "\n" + clientId + "." + timeString + "." + reqBody;
     * @param merchantPrivateKey the private key
     * @return the string
     * @throws Exception the exception
     */
    public static String sign(String reqContent, String signType, String charset, String merchantPrivateKey) throws Exception {
        if (signType.equals("MD5")) {
            return signWithMD5(reqContent, charset, merchantPrivateKey);
        }
        if (signType.equals("RSA")) {
            return signWithSHA1RSA(reqContent, charset, merchantPrivateKey);
        }
        if (signType.equals("RSA2")) {
            return signWithSHA256RSA(reqContent, charset, merchantPrivateKey);
        }
        throw new Exception("sign_type incorrect");
    }

    /**
     * Check the response of Alipay
     *
     * @param rspContent      = httpMethod + " " + uriWithQueryString + "\n" + clientId + "." + timeString + "." + rspBody;
     * @param signature       the signature
     * @param alipayPublicKey the public key
     * @return the boolean
     * @throws Exception the exception
     */
    public static boolean verify(String rspContent, String signType, String charset, String signature, String alipayPublicKey) throws Exception {
        if (signType.equals("MD5")) {
            return signWithMD5(rspContent, charset, alipayPublicKey).equals(signature);
        }
        if (signType.equals("RSA")) {
            return verifySignatureWithSHA1RSA(rspContent, charset, signature, alipayPublicKey);
        }
        if (signType.equals("RSA2")) {
            return verifySignatureWithSHA256RSA(rspContent, charset, signature, alipayPublicKey);
        }
        throw new Exception("sign_type incorrect");
    }

    /**
     * Verify if the received signature is correctly generated with the sender's public key
     *
     * @param rspContent: the original content signed by the sender and to be verified by the receiver.
     * @param signature:  the signature generated by the sender
     * @param strPk:      the public key string-base64 encoded
     * @return
     * @throws Exception
     */
    private static boolean verifySignatureWithSHA1RSA(String rspContent, String charset, String signature, String strPk) throws Exception {
        PublicKey publicKey = getPublicKeyFromBase64String(strPk);

        Signature publicSignature = Signature.getInstance(SHA1WITHRSA);
        publicSignature.initVerify(publicKey);
        publicSignature.update(rspContent.getBytes(charset));

        byte[] signatureBytes = base64Encryptor.decode(signature);
        return publicSignature.verify(signatureBytes);

    }

    /**
     * Verify if the received signature is correctly generated with the sender's public key
     *
     * @param rspContent: the original content signed by the sender and to be verified by the receiver.
     * @param signature:  the signature generated by the sender
     * @param strPk:      the public key string-base64 encoded
     * @return
     * @throws Exception
     */
    private static boolean verifySignatureWithSHA256RSA(String rspContent, String charset, String signature, String strPk) throws Exception {
        PublicKey publicKey = getPublicKeyFromBase64String(strPk);

        Signature publicSignature = Signature.getInstance(SHA256WITHRSA);
        publicSignature.initVerify(publicKey);
        publicSignature.update(rspContent.getBytes(charset));

        byte[] signatureBytes = base64Encryptor.decode(signature);
        return publicSignature.verify(signatureBytes);

    }

    private static String signWithMD5(String reqContent, String charset, String strPrivateKey) throws Exception {
        String content = reqContent + strPrivateKey;
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        md5.update(content.getBytes(charset));
        byte[] digest = md5.digest();
        StringBuilder ret = new StringBuilder();
        for (int i = 0; i < digest.length; i++) {
            String hexString = Integer.toHexString(0xff & digest[i]);
            ret.append((hexString.length() < 2) ? ("0" + hexString) : hexString);
        }
        return ret.toString();
    }


    /**
     * Generate base64 encoded signature using the sender's private key
     *
     * @param reqContent:    the original content to be signed by the sender
     * @param strPrivateKey: the private key which should be base64 encoded
     * @return
     * @throws Exception
     */
    private static String signWithSHA1RSA(String reqContent, String charset, String strPrivateKey) throws Exception {
        Signature privateSignature = Signature.getInstance(SHA256WITHRSA);
        privateSignature.initSign(getPrivateKeyFromBase64String(strPrivateKey));
        privateSignature.update(reqContent.getBytes(charset));
        byte[] s = privateSignature.sign();

        return base64Encryptor.encodeToString(s);
    }

    /**
     * Generate base64 encoded signature using the sender's private key
     *
     * @param reqContent:    the original content to be signed by the sender
     * @param strPrivateKey: the private key which should be base64 encoded
     * @return
     * @throws Exception
     */
    private static String signWithSHA256RSA(String reqContent, String charset, String strPrivateKey) throws Exception {
        Signature privateSignature = Signature.getInstance(SHA1WITHRSA);
        privateSignature.initSign(getPrivateKeyFromBase64String(strPrivateKey));
        privateSignature.update(reqContent.getBytes(charset));
        byte[] s = privateSignature.sign();

        return base64Encryptor.encodeToString(s);
    }

    /**
     * @param publicKeyString
     * @return
     */
    private static PublicKey getPublicKeyFromBase64String(String publicKeyString) throws Exception {
        byte[] b1 = base64Encryptor.decode(publicKeyString);
        X509EncodedKeySpec X509publicKey = new X509EncodedKeySpec(b1);
        KeyFactory kf = KeyFactory.getInstance(RSA);
        return kf.generatePublic(X509publicKey);
    }

    /**
     * @param privateKeyString
     * @return
     * @throws Exception
     */
    private static PrivateKey getPrivateKeyFromBase64String(String privateKeyString) throws Exception {
        byte[] b1 = base64Encryptor.decode(privateKeyString);
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(b1);
        KeyFactory kf = KeyFactory.getInstance(RSA);
        return kf.generatePrivate(spec);
    }

    /**
     * URL  encode
     *
     * @param originalStr
     * @param characterEncoding
     * @return
     * @throws UnsupportedEncodingException
     */
    private static String encode(String originalStr,
                                 String characterEncoding) throws UnsupportedEncodingException {
        return URLEncoder.encode(originalStr, characterEncoding);
    }

    /**
     * URL decode
     *
     * @param originalStr
     * @param characterEncoding
     * @return
     * @throws UnsupportedEncodingException
     */
    private static String decode(String originalStr,
                                 String characterEncoding) throws UnsupportedEncodingException {
        return URLDecoder.decode(originalStr, characterEncoding);
    }

    public static void setBase64Encryptor(Base64Encryptor customBase64Encryptor) {
        base64Encryptor = customBase64Encryptor;
    }
}
